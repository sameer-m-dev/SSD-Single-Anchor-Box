# -*- coding: utf-8 -*-
"""SSD Testing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-wcdXz6IThfHmyVQJ_3JIHfqAXrkOrfQ
"""

# ! pip install numpy==1.16 tensorflow-object-detection-api

# Commented out IPython magic to ensure Python compatibility.
# using tf v1
# %tensorflow_version 1.x

# importing required libraries
import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2' 
import numpy as np
import tensorflow as tf
import cv2
import pandas as pd
import argparse

from collections import defaultdict
from matplotlib import pyplot as plt

from object_detection.utils import ops as utils_ops
from object_detection.utils import label_map_util
from object_detection.utils import visualization_utils as vis_util

# Commented out IPython magic to ensure Python compatibility.
# This is needed to display the images.
# %matplotlib inline

# Creating an argument parser
parser = argparse.ArgumentParser()
parser.add_argument("--model_dir", default="model",
                    help="dir where frozen_inference_graph.pb is stored")
parser.add_argument("--image", default="",
                    help="image to be used for testing")    
parser.add_argument("--threshold", default=0.7,
                    help="object detection threshold")                       
args = parser.parse_args()


# paths to main folders: with frozen graph, with classes labels, pbtxt file
PATH_TO_MODEL = args.model_dir+'/frozen_inference_graph.pb'
PATH_TO_LABELS = args.model_dir+'/pack.pbtxt'
NUM_CLASSES = 1

# load frozen graph
detection_graph = tf.Graph()
with detection_graph.as_default():
    od_graph_def = tf.GraphDef()
    with tf.gfile.GFile(PATH_TO_MODEL, 'rb') as fid:
        serialized_graph = fid.read()
        od_graph_def.ParseFromString(serialized_graph)
        tf.import_graph_def(od_graph_def, name='')

# load categories (we have only 1 category pack)
label_map = label_map_util.load_labelmap(PATH_TO_LABELS)
categories = label_map_util.convert_label_map_to_categories(
    label_map, max_num_classes=NUM_CLASSES, use_display_name=True)
category_index = label_map_util.create_category_index(categories)

# let's write function that executes detection
def run_inference_for_single_image(image, image_tensor, sess, tensor_dict):
    # Run inference
    expanded_dims = np.expand_dims(image, 0)
    output_dict = sess.run(tensor_dict, feed_dict={image_tensor: expanded_dims})
    # all outputs are float32 numpy arrays, so convert types as appropriate
    output_dict['num_detections'] = int(output_dict['num_detections'][0])
    output_dict['detection_classes'] = output_dict['detection_classes'][0].astype(np.uint8)
    output_dict['detection_boxes'] = output_dict['detection_boxes'][0]
    output_dict['detection_scores'] = output_dict['detection_scores'][0]
    return output_dict

# it is useful to be able to run inference not only on the whole image,
# but also on its parts
# cutoff - minimum detection scrore needed to take box
def run_inference_for_image_part(image_tensor, sess, tensor_dict, 
                                 image, cutoff, ax0, ay0, ax1, ay1):
    boxes = []
    im = image[ay0:ay1, ax0:ax1]
    h, w, c = im.shape
    output_dict = run_inference_for_single_image(im, image_tensor, sess, tensor_dict)
    for i in range(100):
        if output_dict['detection_scores'][i] < cutoff:
            break
        y0, x0, y1, x1, score = *output_dict['detection_boxes'][i], \
                                output_dict['detection_scores'][i]
        x0, y0, x1, y1, score = int(x0*w), int(y0*h), \
                                int(x1*w), int(y1*h), \
                                int(score * 100)
        boxes.append((x0+ax0, y0+ay0, x1+ax0, y1+ay0, score))
    return boxes

# additional helper function to work not with coordinates but with percentages
def run_inference_for_image_part_pcnt(image_tensor, sess, tensor_dict, 
                                 image, cutoff, p_ax0, p_ay0, p_ax1, p_ay1):
    h, w, c = image.shape
    max_x, max_y = w-1, h-1
    return run_inference_for_image_part(
                                image_tensor, sess, tensor_dict, 
                                image, cutoff, 
                                int(p_ax0*max_x), int(p_ay0*max_y), 
                                int(p_ax1*max_x), int(p_ay1*max_y))

# function to display image with bounding boxes
def display_image_with_boxes(image, boxes, p_x0=0, p_y0=0, p_x1=1, p_y1=1):
    image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
    for x0, y0, x1, y1, score in boxes:
        image = cv2.rectangle(image, (x0, y0), (x1, y1), (0,255,0), 5)
    if p_x0 != 0 or p_y0 !=0 or p_x1 != 1 or p_y1 != 1:
        h, w, c = image.shape
        max_x, max_y = w-1, h-1
        image = cv2.rectangle(image, 
                              (int(p_x0*max_x), int(p_y0*max_y)), 
                              (int(p_x1*max_x), int(p_y1*max_y)), (0,0,255), 1)
    plt.figure(figsize=(14, 14))
    plt.imshow(image)

# initializations function
def initialize_graph():
    ops = tf.get_default_graph().get_operations()
    all_tensor_names = {output.name
                        for op in ops
                        for output in op.outputs}
    tensor_dict = {}
    for key in ['num_detections', 'detection_boxes',
                'detection_scores', 'detection_classes',
                'detection_masks']:
        tensor_name = key + ':0'
        if tensor_name in all_tensor_names:
            tensor_dict[key] = tf.get_default_graph().get_tensor_by_name(tensor_name)
    image_tensor = tf.get_default_graph().get_tensor_by_name('image_tensor:0')
    return image_tensor, tensor_dict

# function for non-maximum suppression
def non_max_suppression(boxes, overlapThresh):
    if len(boxes) == 0:
        return np.array([]).astype("int")

    if boxes.dtype.kind == "i":
        boxes = boxes.astype("float")
 
    pick = []

    x1 = boxes[:,0]
    y1 = boxes[:,1]
    x2 = boxes[:,2]
    y2 = boxes[:,3]
    sc = boxes[:,4]
 
    area = (x2 - x1 + 1) * (y2 - y1 + 1)
    idxs = np.argsort(sc)
 
    while len(idxs) > 0:
        last = len(idxs) - 1
        i = idxs[last]
        pick.append(i)
 
        xx1 = np.maximum(x1[i], x1[idxs[:last]])
        yy1 = np.maximum(y1[i], y1[idxs[:last]])
        xx2 = np.minimum(x2[i], x2[idxs[:last]])
        yy2 = np.minimum(y2[i], y2[idxs[:last]])
 
        w = np.maximum(0, xx2 - xx1 + 1)
        h = np.maximum(0, yy2 - yy1 + 1)

        #todo fix overlap-contains...
        overlap = (w * h) / area[idxs[:last]]
         
        idxs = np.delete(idxs, np.concatenate(([last],
            np.where(overlap > overlapThresh)[0])))
    
    return boxes[pick].astype("int")

# main function to do a sliding windows inference with non-maximum suppression
def do_sliding_window_inference_with_nm_suppression(file, cutoff, display_image=False):
    with detection_graph.as_default():
        with tf.Session() as sess:
            if (file != ""):
                image_tensor, tensor_dict = initialize_graph()
                image = cv2.imread(file)
                h, w, c = image.shape
                boxes = run_inference_for_image_part_pcnt(
                image_tensor, sess, tensor_dict, image, cutoff, 0, 0, 1, 1)
                a = np.array(boxes)
                mean_dx = int(np.mean(a[:,2]-a[:,0]))
                mean_dy = int(np.mean(a[:,3]-a[:,1]))
                step_x, step_y = mean_dx, mean_dy
                window_size = 2*mean_dy
                boxes = []
                y0 = 0
                while y0 < h-1:
                    x0 = 0
                    while x0 < w-1:
                        x1, y1 = x0 + window_size, y0 + window_size
                        boxes += run_inference_for_image_part(
                            image_tensor, sess, tensor_dict, image, cutoff, 
                            x0, y0, x1, y1)
                        x0 += step_y
                    y0 += step_x
                boxes = non_max_suppression(np.array(boxes), 0.5)
                if display_image is True:
                    display_image_with_boxes(image, boxes)
                print ("Number of products found: {}".format(len(boxes)))
            else:
                print("_____No file provided_____")

# calling main function 
do_sliding_window_inference_with_nm_suppression(args.image, float(args.threshold), False) 

